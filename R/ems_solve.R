#'Configure and solve model
#'
#'@description `ems_solve()` solves the constrained optimization
#'  problem according to a range of runtime configuration
#'  options. In order to solve the model, a `teems` Docker image
#'  (\href{https://github.com/teemsphere/teems-solver}{teems-solver})
#'  must be built.Singularity, accuracy, and error checks are
#'  carried out following a successful run.
#'
#'@param cmf_path Character length 1 (default is `NULL`), path to
#'  the cmf file generated by [`ems_deploy()`].
#'@param n_tasks Integer length 1 (default is `1L`), number of
#'  tasks to run in parallel. Must be `1L` if `"matrix_method"`
#'  == "LU".
#'@param n_subintervals Integer length 1 (default is `1L`),
#'  number of subintervals for the applied shock. More
#'  subintervals may alleviate accuracy issues stemming from
#'  large shock magnitudes.
#'@param matrix_method Character of length 1, matrix solution
#'  method (default is `"LU"`). Choices:
#'   * `"LU"`: Standard LU decomposition, the most robust and
#'  potentially slowest for a large model. `"n_tasks"` must be
#'  `1L` if `"matrix_method"` == "LU". For use with both static
#'  and dynamic models.
#'   * `"DBBD"`: Doubly bordered block diagonal, parallel solution
#'  method for static models. Potentially faster than `"LU"`
#'  although less robust.
#'   * `"SBBD"`: Singly bordered block diagonal, parallel solution
#'  method for intertemporal models. Potentially faster than
#'  `"LU"` although less robust.
#'   * `"NDBBD"`: Nested doubly bordered block diagonal, parallel
#'  solution method for large intertemporal models with many
#'  timesteps.
#'@param solution_method The solution method to be used, default
#'  is the "one-step" `"Johansen"`. Choices:
#'   * `"Johansen"`: The Johansen method is fast however it should
#'  only be used as a rough approximation due to handling of
#'  nonlinear equations. See:
#'  https://www.copsmodels.com/gpmanual.htm#gpd1.2.13
#'   * `"mod_midpoint"`: The modified midpoint method
#'  performs multiple passes. See:
#'  https://www.copsmodels.com/gpmanual.htm#gpd3.12.2
#'@param steps Integer length 3 (default is `c(2L, 4L, 8L)`). A
#'  vector of steps for the modified midpoint method, must be all
#'  odd or all even and length 3. Additional steps may improve
#'  accuracy for some model runs.
#'@param laA Integer length 1 (default is `300L`). The laA memory
#'  parameter for solver pertaining to matrix methods `"LU"` and
#'  `"SBBD"`. Value is in percentages. Increase gradually if
#'  prompted via "Error return from MA48B/BD because LA is ..."
#'@param laD Integer length 1 (default is `200L`). The laD memory
#'  parameter for solver pertaining to matrix methods `"DBBD"`
#'  and `"NDBBD"`. Value is in percentages. Increase gradually if
#'  prompted via "Error return from MA48B/BD because LA is ..."
#'@param laDi Integer length 1 (default is `500L`). The laDi
#'  memory parameter for solver pertaining to matrix method
#'  `"NDBBD"`. Value is in percentages. Increase gradually if
#'  prompted via "Error return from MA48B/BD because LA is ..."
#'@param terminal_run Logical length 1 (default is `FALSE`). When
#'  `TRUE`, the function is exited without running the solver.
#'  This allows the user to close any R IDE or other programs
#'  prior to running from the terminal.
#'@param suppress_outputs Logical length 1 (default is `FALSE`).
#'  When `TRUE` solver outputs are not automatically converted
#'  into structured data with [`ems_compose`].
#'
#' @examples
#' \dontrun{
#' # See \href{https://github.com/teems-org/teems-scripts}{teems-scripts}
#' # for a range of solution options.
#'}
#'
#' @return A tibble containing model output variables and
#'  coefficients. Alternatively, if `"suppress_outputs"` is
#'  `TRUE`, file path to a CMF file that may be used with
#'  [`ems_compose`].
#'
#' @export
ems_solve <- function(cmf_path = NULL,
                      n_tasks = 1L,
                      n_subintervals = 1L,
                      matrix_method = c("LU", "DBBD", "SBBD", "NDBBD"),
                      solution_method = c("Johansen", "mod_midpoint"),
                      steps = c(2L, 4L, 8L),
                      laA = 300L,
                      laD = 200L,
                      laDi = 500L,
                      terminal_run = FALSE,
                      suppress_outputs = FALSE,
                      n_timesteps = NULL
) {
call <- match.call()
.check_docker(image_name = "teems",
              call = call)
timeID <- format(x = Sys.time(), "%H%M")
paths <- .get_solver_paths(cmf_path = cmf_path,
                           timeID = timeID,
                           call = call)
# n_timesteps can be carried as an attribute but better to deal with it in the solver
mod_arg <- .validate_solver_args(n_tasks = n_tasks,
                                 n_subintervals = n_subintervals,
                                 matrix_method = matrix_method,
                                 solution_method = solution_method,
                                 steps = steps,
                                 n_timesteps = n_timesteps,
                                 paths = paths,
                                 call = call)
cmds <- .construct_cmd(
  paths = paths,
  terminal_run = terminal_run,
  timeID = timeID,
  n_tasks = n_tasks,
  steps = steps,
  laA = laA,
  laDi = laDi,
  laD = laD,
  matsol = mod_arg$matsol,
  solmed = mod_arg$solmed,
  n_subintervals = mod_arg$n_subintervals,
  n_timesteps = mod_arg$n_timesteps,
  nesteddbbd = mod_arg$nesteddbbd,
  enable_time = mod_arg$enable_time
)
# need a process running in parallel, grepping output for error and then kill appropriate PID
if (isFALSE(cmds)) {return(invisible(NULL))}
elapsed_time <- system.time(system(cmds$solve))
.check_solver_log(elapsed_time = elapsed_time,
                  solve_cmd = cmds$solve,
                  paths = paths,
                  call = call)
system(cmds$sol_parse, ignore.stdout = TRUE)
if (!suppress_outputs) {
output <- ems_compose(cmf_path = cmf_path,
                      type = "all")
return(output)
}
return(invisible(NULL))
}
