#' Loads, validates, and writes all model components
#'
#' @description `ems_deploy()` combines outputs from all model
#'   components, producing a solution-ready directory. Outputs
#'   from [`ems_data()`] and [`ems_model()`] are required inputs
#'   to `"data"`, `"model"` respectively.
#' 
#'
#' @param data A list of data.tables generated by the function
#'   [`ems_data()`] or equivalent.
#' @param model A tibble generated by the function
#'   [`ems_model()`] or equivalent.
#' @param shock A `shock` object or in the case of multiple
#'   shocks, list of objects produced by [`ems_shock()`] (default
#'   is `NULL`). In the case of `NULL`, a `NULL` shock will be
#'   carried out which effectively returns base data.
#' @param swap_in Character vector (default is `NULL`), or `swap`
#'   object created by [`ems_swap()`], or a list of any
#'   combination of character vectors and swap objects.
#'   Represents model variable or variables to be made exogenous.
#' @param swap_out Character vector (default is `NULL`), or
#'   `swap` object created by [`ems_swap()`], or a list of any
#'   combination of character vectors and swap objects.
#'   Represents model variable or variables to be made
#'   endogenous.
#' @param write_dir Character of length 1 (default is
#'   `tools::R_user_dir("teems", "cache")`), directory where
#'   input files will be written and model solution will be
#'   carried out. If persistence is desired, a user-provided
#'   directory must be provided.
#' @param closure_file A character of length 1 (default is
#'   `NULL`). File name in working directory or path to a ".cls"
#'   closure file. See
#'   \href{https://github.com/teems-org/teems-models}{teems-models}
#'   for internally available closures and formatting for
#'   user-provided closures.
#' @param shock_file Character of length 1, file name in working
#'   directory or path to a csv representing the final shock
#'   file. No checks or modifications will be conducted on this
#'   file.
#'   
#' @return File path to a CMF file necessary to execute
#'   [`ems_solve()`].
#'
#' @details `ems_deploy()` consolidates all user inputs and
#'   carries out all operations necessary to run a CGE model. The
#'   output file path serves as a required input to
#'   [`ems_solve()`].
#'
#' @seealso [`ems_model()`] for generating the input to
#'   `"model"`.
#' @seealso [`ems_data()`] for generating the input to
#'   `"data"`.
#' @seealso [`ems_shock()`] for generating the input to
#'   `"shock"`.
#' @seealso [`ems_swap()`] for loading both full variable swaps
#'   as well as element-specific swaps.
#' @seealso [`ems_solve()`] for loading the output of this
#'   function.
#'
#' @examples
#' \dontrun{
#' # See \href{https://github.com/teems-org/teems-scripts}{teems-scripts}
#' # for a range of sample scripts.
#' }
#' @export
ems_deploy <- function(data,
                       model,
                       shock = NULL,
                       swap_in = NULL,
                       swap_out = NULL,
                       write_dir = tools::R_user_dir("teems", "cache"),
                       closure_file = NULL,
                       shock_file = NULL) {
  if (missing(data)) {
    .cli_missing(data)
  }
  if (missing(model)) {
    .cli_missing(model)
  }
  call <- match.call()
  args_list <- mget(x = names(x = formals()))
  metadata <- attr(data, "metadata")
  attr(metadata, "file") <- "metadata.rds"
  sets <- .finalize_sets(
    sets = data[purrr::map_lgl(data, inherits, "set")],
    set_extract = model[model$type == "Set",],
    coeff_extract = model[model$type == "Coefficient",],
    time_steps = attr(data, "time_steps"),
    reference_year = metadata$reference_year,
    call = call,
    data_call = attr(data, "call"),
    model_call = attr(model, "call")
  )
  v <- .validate_deploy_args(
    a = args_list,
    sets = sets,
    call = call,
    data_call = attr(data, "call")
  )
  closure <- .validate_closure(
    closure = v$closure,
    var_omit = attr(v$model, "var_omit"),
    sets = sets,
    var_extract = model[model$type == "Variable",],
    call = call
  )
  closure <- .finalize_closure(
    swap_in = v$swap_in,
    swap_out = v$swap_out,
    closure = closure,
    sets = sets,
    var_extract = model[model$type == "Variable",],
    call = call
  )
  if (!is.null(v$shock)) {
    shocks <- .finalize_shocks(
      shock = v$shock,
      shock_file = v$shock_file,
      closure = closure,
      sets = sets,
      var_extract = model[model$type == "Variable",]
    )
  } else {
    shocks <- structure(NA,
                        file = "null_shock.shf",
                        class = c("shock", class(NA)))
  }
  data <- .finalize_data(
    data = data,
    sets = sets,
    model = model,
    write_dir = write_dir,
    call = call
  )
  tab <- .finalize_tab(model = model)

  cmf <- .finalize_cmf(
    model = model,
    shock_file = attr(shocks, "file"),
    tab_file = attr(tab, "file"),
    cls_file = attr(closure, "file"),
    write_dir = v$write_dir
  )
  tab_path <- .ems_write(
    input = tab,
    write_dir = v$write_dir
  )
  closure_path <- .ems_write(
    input = closure,
    write_dir = v$write_dir
  )
  shock_path <- .ems_write(
    input = shocks,
    write_dir = v$write_dir
  )
  cmf_path <- .ems_write(input = cmf)
  attr(cmf_path, "tab_path") <- tab_path
  data_path <- lapply(data,
    .ems_write,
    write_dir = v$write_dir
  )
  .out_mkdir(write_dir = v$write_dir)
  .diagnostic_output(
    tab_path = tab_path,
    cmf_path = cmf_path,
    closure_path = closure_path,
    shock_path = shock_path,
    data_path = unique(data_path),
    sets = sets,
    closure = closure,
    shocks = v$shock,
    metadata = metadata
  )
  cmf_path
}
